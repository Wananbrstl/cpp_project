[toc]

# 多线程/进程

> **进程** 是资源分配的最小单位，**线程**是CPU分配的最小单位。

我们要想高效使用CPU，就必须多进程（多线程在OS重不是必须的），多进程往往是需要同步的，其中最典型的就是**生产者和消费者**模型，也就是说进程/线程是走走停停的。

切换线程/进程是有资源代价的，这里的资源既包括时间也包括空间，在现代的操作系统中，我们普遍考虑用空间换时间。线程的切换代价是小于进程的切换代价的，此外，现在的多核CPU多多线程的支持也很友好，在多核CPU中，多个CPU共享CaChe及MMU。相比于进程，线程少了一步内存空间的转换，都是在一个进程中折腾。根据内存分段分页机制，每个进程之间的空间是相互独立的，这从OS层面就已经决定了这样的格局，也正是因为有了分段机制，程序员不必担心内存问题，可以想象我们拥有（根据内存大小有关）相同大小的内存空间，分段机制会将给定的 **逻辑地址**转化为**线性地址**，这里的转换通过ldtr（局部描述表寄存器），然后我们可以通过这个寄存器找到段基址，然后通过段表号和段基址找到线性地址（或虚拟地址），然后直接甩给MMU去分页查找（分页机制是为了适应实际内存，如果我们只考虑分段，那么内存会出现很多碎片），且我们在考虑分页的时候，通常会生成多级页目录，当然也可以使用块表TLB去加快寻找速度。

> 总之，在内存访问或者其他地方想要提高速度，最佳的办法就是缓存（CaChe），也正是实际中，我们通常只访问最近数据这一事实分不开。

## 进程间的同步和信号量

首先，我们来考虑这样一个实际的例子，公交车司机和售票员的配合情况，我们可以抽象成两个进程。

公交车司机的运行需要与售票员进行配置，当售票员发出了人员上齐的信号，司机会执行启动车辆；相同地，当司机发车到站的信号时，售票员会打开车门进行售票。正是这样的配合，使得整个系统能够顺利执行。

### 消费者和生产者例子

一个经典的多进程，多线程的例子就是生产者和消费者，可以使用c++来进行描述：
```c++
#define BUFFER_SIZE 10

typedef struct {...}item;
item buffer[BUFFER_SIZE];

int in = out = counter = 0;

// 生产者
while(true) {
    while(counter >= BUFFER_SIZE); // 满
    buferr[in] = item;
    in = (in + 1) % BUFFER_SIZE;
    counter++;
}

//消费者
while(true) {
    while(counter == 0); // 空
    item = buffer[out;]
    out = (out + 1) % BUFFER_SIZE;
    counter--;
}
```

> 从上面的例子，再一次说明，进程/线程的合作/同步其实就是“走走停停”，我们需要把握时机。

上面只有一个生产者和消费者，我们应该注意到有很多生产者和消费者的情况。如果有两个生产者和一个消费者，那么这种方式，一个消费者就只能唤醒一个生产者，也就是消费者消费完，就会让两个生产者进行资源抢夺，不能同时让两个生产者同时生产。

所以，**信号量**的概念就被引出来，我们可以想象路口的信号控制，最普通的就是红绿灯去控制，因为只有两条主道，如果多条道路的话，我们就需要信号量去设计出更复杂的配合关系。

- counter来进行判断就不可行（此外我们还需要知道有个生产者和几个消费者需要唤醒） 
    - 也正是因为需要线程(内核)/进程唤醒，所以，信号量不可能是用户态，一定是在内核态。
- 根据一个量（信号量）判断是否发出信号量

### Dijstra提出的信号量的实现
```c++
typedef struct Semaphore {
    int value;
    PCB* queue; // 需要在内核态运行
}Semphore;

// 两个操作
void P(Semphore S); // test     -   sleep
void V(Semphore S); // include  -   wake up

/* test */
void P(Semphore s){ 
    s.value--;
    if(s.value < 0) {
        sleep(s.queue);
    }
}

/* wake up */
void V(Semphore s) {
    s.value++;
    if(s.value <= 0) {
        wake_up(s.queue);
    }
}
```

**问题一： 信号量的变量代表的是可用资源数，为什么资源数很多但是不唤醒呢？**

答：如果变量为正，之前就为正，说明之前没有线程在等待。

**问题二： 为什么信号量在为0的时候需要唤醒？**

答：因为在信号量加1之前，信号量为-1，有一个在等待资源，所以这时候需要唤醒。

### 用信号量解决生产者-消费者同步问题

生产者执行的条件是缓冲队列没有满的情况下才能继续执行

消费者的执行条件是缓冲队列在不为空的情况下才能继续执行
```c++
#define NUM 1000

Semphore empty  = NUM;
Semphore full   = 0;
Semphore mtx    = 1;

void producter() {
    P(empty);
    P(mtx);
    ...
    V(full);
    V(mtx);
}

void sum() {
    P(full);
    P(mtx);
    ...
    V(full);
    V(empty);
}
```


