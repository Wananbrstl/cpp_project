# 55个提高cpp的做法

## 第一部分-习惯c++

### 1. 将c++看成一个语言联邦
### 2. 使用const,enum,inline代替#define
### 3. 多使用const
### 4. 确保对象初始化之前已经初始化

## 第二部分-构造/析构/赋值

### 5. **明确编译器为你创建了哪些函数**
当我们定义一个空类的时候，编译器会默默为我们提供五个必须的函数:
- 构造函数
- 拷贝构造函数
- 析构函数
- 复制赋值函数
> 需要注意的是，c++11之后编译器其实会为我们默认提供一个**移动构造函数**，**移动复制函数**
```c++
class Demo{
  // 空类
  // 编译器为我们提供：
  Demo(){} // ---> 默认构造函数
  Demo(const Demo& other){/* 调用所有类成员的赋值函数 */} //---> 默认拷贝函数
  Demo(Demo&&); // 
  Demo& operator=(const Demo& other);
  ~Demo(){} // --->默认析构函数
};
```
构造、析构、拷贝构造和赋值操作符、移动构造和赋值操作符
### 6. **若不想编译器为你产生默认函数，明确拒绝**
如条例5所示，如果不想声明默认给定的函数，那么我们要明确拒绝。在c++11之后可以使用如下形式：
```c++
class A{
  A() = delete;
  A(const A&) = delete;
  ~A() = delete;
}
```
这样，编译器就不会为我们声明`delete`的函数。
### 7. **为多态基类声明virtual析构函数**
> 当基类的指针指向了派生类（这是多态的基础），如果不为基类声明为析构函数，那么根据多态函数的寻找方法，由于子类重载了父类的析构函数，所以此时不会调用父类的析构函数，可能会导致内存泄漏等。
- 所以，当一个类可以确定是作为基类使用的时候，就应该将它的析构函数声明为`virtual`。
- 但是，不确定一个类是否会被继承的时候，那么就不应该随便使用`virtual`去修改析构函数
- 另外，如果一个类确定不会作为基类，那么可以将它的析构函数或其他函数声明为`finial`，确保不会被重载（c++11）。
### 8. **别让异常逃离析构函数**
### 9. **不要在构造和析构过程中调用virtual函数**
### 10. **在operator=函数中返回reference to *this**
### 11. **在operator=函数中处理自我赋值的情况**
### 12. **赋值对象不要忘记每一个成员变量

### 第三部分-资源的管理

