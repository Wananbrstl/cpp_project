# 红黑树的性质

1. 红黑树的节点非黑即红
2. 树根节点是黑色的
3. 所有叶子节点是黑色的
4. 红色节点的两个子节点都必须是黑色的
5. 从根节点到所有子节点（首尾都是黑色）上的黑色节点数量相同。

> 从上面的性质，我们可以知道，红黑树（Read Black Tree）是通过树高来实现平衡的。并且树高条件并没有AVL树那么严格，最长边和最短边的长度可以相差两倍（最长的情况是黑红黑红...黑，最短的情况全是黑）

# 红黑树的调整策略

1. 插入调整站在**祖父节**看
2. 删除节点站在**父节点**看
3. 插入、删除一共**五种**情况


## 插入节点的两种情况

> 首先明确一点，插入的节点一定是红色（我们在插入之前是平衡的，也就是每条路径上的黑色节点是一样的，那么如果插入的是黑的，平衡条件5破坏了）
然后，如果插入红色节点，发生冲突的情况一定是父节点是红色的，因为平衡条件4红色的两个子节点都应该是黑色的，所以插入的特殊情况就是父节点是红色，并且根据叔叔节点的红/黑来判断如果平衡。

问：有没有可能没有叔叔节点？
答：不可能，因为我们用NIL来代替了空节点，也就是说，如果没有左/右子树，那么左/右子树的颜色就是黑色（平衡条件3）

### 情况一： 叔叔节点是红色
这种情况下，祖父节点一定是黑色，由于每条路径上的黑色节点应该一样，并且插入节点的父节点是红色，又冲突了，所以将父亲和叔叔的颜色改为黑色即可。

### 情况二： 叔叔节点是黑色
这种情况下，可以类似于AVL树的树高调整的四种情况进行分析，我们这里只分析站在祖父节点的角度，左子树和左孙树是红色的情况（LL型）

在这种情况下，我们可以来分析下有哪些节点的颜色是确定的：
- 首先，根据冲突条件，插入节点以及其父节点一定是红色，根据分类叔叔节点是黑色。
- 其次，根据平衡条件4，插入节点的祖父节点一定是黑色，插入节点的兄弟节点也是黑色。
- 最后，叔叔节点的两个子树不确定，因为其为黑色节点。

        黑
       /  \
      /    \
     红    黑
    /  \
   红  黑    

如上图所示，我们可以得出当前的颜色树图。

针对这种情况，我们可以类比AVL树LL型的调整策略进行大右旋，然后得到如下的树：

        红
       /   \
      /     \
     红     黑
    /  \   /  \
   黑  黑 黑  黑

我们根据平衡条件5，可以通过调整上树的祖父节点为黑色，以及叔叔节点为红色搞定，其他情况类似。

        黑
       /   \
      /     \
     红     红
    /  \   /  \
   黑  黑 黑  黑

## 删除的情况

> 在删除的情况下， 我们站在父节点的视角上进行调整，与插入类似，我们讨论兄弟节点的情况。

### 兄弟节点是黑色

#### 兄弟节点的子节点都是黑色

这是最简单的情况，将父节点的颜色加一层，两个子节点的颜色减去一层。

#### 兄弟节点的一个节点是红色。

##### RR或者LL类型

这里我们以父节点的左节点是双重黑色节点，右子节点的右节点为红色为例子说明第一种情况。

如果是RR类型:
- 首先，将兄弟节点的颜色变成父节点的颜色
- 双重颜色节点减去一重颜色。
- 进行大左旋，将兄弟节点提上来，然后将变换的兄弟的两个子节点颜色改成黑色。

##### 如果是RL或者LR的情况

这种情况和AVL树的平衡类似，都是变换成RR或者LL的情况。

如果是RL类型：
- 首先将兄弟节点的颜色改成红色，兄弟节点的左节点改成黑色
- 兄弟节点进行右旋。

### 兄弟节点是红色

这种情况，我们一般的处理方式就是将红色节点放在根节点

```c++
root->color = RED;
root->right>color = BLACK;
root = left_rotate(right);
root = erase_matain(root);

```
